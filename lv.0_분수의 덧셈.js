// 문제 설명
// 첫 번째 분수의 분자와 분모를 뜻하는 numer1, denom1, 두 번째 분수의 분자와 분모를 뜻하는 numer2, denom2가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.

// 제한사항
// 0 <numer1, denom1, numer2, denom2 < 1,000

function solution(denum1, num1, denum2, num2) {
  let answer = [];
  const denum = denum1 * num2 + denum2 * num1;
  const num = num1 * num2;

  let minNum;
  if (denum < num) {
    minNum = denum;
  } else {
    minNum = num;
  }
  // 이 아래 식들이 minNum 이 1이 될때까지 감소하면 무조건 리턴이 되기 때문
  while (true) {
    //만약 한번에 분자분모를 나눈다면 그 값은 gcd가 되어 배열을 만족할 수 있음.
    if (denum % minNum === 0 && num % minNum === 0) {
      return [denum / minNum, num / minNum];
    }
    // 다만 아닐 경우(두개의 if를 만족못하는) minNum을 1씩 깎아봐야함.
    minNum -= 1;
  }
}

// 1. 분모 덧셈>
// 단순하게 분수를 더한다고 생각하면, 분모끼리 곱해준뒤, 서로의 분모에 곱한 값을 분자에게도 곱해준 뒤 더하면 된다. 이를테면 1/2 + 3/4은, (1*4 + 3*2) / (2*4) 로 계산이 된다. 그럼 1차적으로 10/8 이 나온다.

// 2. 분자문모 최대공약수로 나누기>
// 그럼 조건을 맞추기 위해 10/8을 기약분수로 만들기 위해선 최대 공약수인 2로 나눠주는 것이다. 그래서 (10/8)/2 -> 5/4가 된다. 식으로 표현하면 1번의 기약분수 이전의 분수(10/8)의 분자 분모에 각각 최대 공약수(gcd)를 나눠주면 된다.

// 3. 분자 분모중 작은수로 나눠보기>
// 그렇다면 분자 분모의 최대공약수를 구하는 법은, 분자 분모중 작은 수(minNum이라고 지칭)를 구하고, 분자와 분모에 나눠보는 것이다.(무식하지만, 가장 단순한 방법)이를테면 4/8 에서 작은 수인 4는 '운좋게' 둘다 나누어 떨어지면서 두 수의 최대공약수가 될 수 있다.

// 4. 배열완성?>
// 우린 이 수를 사용하여 기약 분수를 만들기 위한 최대공약수로 활용할 수 있고, 기약분수의 분자 분모 값은 결국 최종 배열로 리턴된다. -> return[denum / minNum , num / minNum]; 하지만, 분자 혹은 분모가 한번에 두 수의 최대 공약수일 확률은 그다지 높지 않다. 그 minNum이 최대공약수가 아닐 경우에는, minNum에 계속에서 -1을 해주면서 줄여나갈 수 밖에 없다. 정말 심한 경우(ex 13/23)에는 1까지(모든 정수는 1에 나뉘므로)갈 수도 있다.

// 5. 1씩 깎아가며 최대 공약수 찾기>
// 그래서 while문으로 무한반복을 돌려서 return이 만족(분자분모가 나뉘는 것을 둘다 만족 할 때까지) minNum을 깎는 식을 대입한다. 결국 minNum이 분자 분모를 둘다 나눠버리는 수가 나오면, 그 수는 최대 공약수가 되어 배열을 완성한다.

// 혼자 힘으로 풀기 힘들어서, 제가 이해가능한 선에서 여러 식을 참고 했습니다..
