// 문제 설명
// 한국중학교에 다니는 학생들은 각자 정수 번호를 갖고 있습니다. 이 학교 학생 3명의 정수 번호를 더했을 때 0이 되면 3명의 학생은 삼총사라고 합니다. 예를 들어, 5명의 학생이 있고, 각각의 정수 번호가 순서대로 -2, 3, 0, 2, -5일 때, 첫 번째, 세 번째, 네 번째 학생의 정수 번호를 더하면 0이므로 세 학생은 삼총사입니다. 또한, 두 번째, 네 번째, 다섯 번째 학생의 정수 번호를 더해도 0이므로 세 학생도 삼총사입니다. 따라서 이 경우 한국중학교에서는 두 가지 방법으로 삼총사를 만들 수 있습니다.

// 한국중학교 학생들의 번호를 나타내는 정수 배열 number가 매개변수로 주어질 때, 학생들 중 삼총사를 만들 수 있는 방법의 수를 return 하도록 solution 함수를 완성하세요.

// 제한사항
// 3 ≤ number의 길이 ≤ 13
// -1,000 ≤ number의 각 원소 ≤ 1,000
// 서로 다른 학생의 정수 번호가 같을 수 있습니다.

//문제는 간단하게, 배열중 3개 값의 합이 0이 되는 경우의 수를 구하는 것이다.
//여러번 수정을 거쳤다. 처음에는 i=0, j=1, j=2 로 단순하게 생각없이 절대값으로 초깃값을 설정했다. 이러면 안되는게, 배열 길이가 5라고 했을때, k가 2부터 5까지 반복하고나면 j가 2로 오를텐데, 그다음에도 k가 또 2부터 시작하는 것이다. 즉, i,j,k순서대로 하나씩 인덱스가 높은상태로 시작하는 것은 마찬가지이지만, 상대적으로 변화가 이루어져야 하므로 각각 i=0, j=i+1, k=j+1 로 설정한다.
//다음으로 생각못한건 i는 length -2 를 해주고, j는 length - 1을 해준건데, 손으로 각각의 경우를 다 구하다보니 알겠다. for문이 3중으로 반복되고 있는게 핵심인데, 배열길이와 관계없이 i가 배열길이 -2만큼 갔을때, j와k는 각각 마지막 한가지 경우밖에 도출 할 수 없다. 예를 들어 [-2, 3, 0, 2, -5]에서 i가 배열길이-2는 3이 되고, i<number.length-2이므로 i<3이되고, i는 2까지 가게 설정되는 이유는 i가 2일경우 number[2], 즉 i,j,k에 의해 (0,2,-5)의 값 하나밖에 없다. k는 더이상 탐색할 그 이상의 길이가 없다. 즉 이게 마지막 탐색 경우가 된다. 삼총사이므로 i의 최대 탐색범위는 배열길이에서 -2를 해줄때까지이다.

function solution(number) {
  let result = 0;
  for (let i = 0; i < number.length - 2; i++) {
    for (let j = i + 1; j < number.length - 1; j++) {
      for (let k = j + 1; k < number.length; k++) {
        if (number[i] + number[j] + number[k] === 0) result += 1;
      }
    }
  }
  return result;
}

//다른 풀이1>
//잊고 있던 continue를 사용했다. if안의 조건이 참일때(0이 false이므로 0이 아닌경우에만)만, 뒤의 코드를 한번 건너뛴다. 이말은 answer++를 실행하지 않고 다음 루프로 넘어간다는 뜻. 즉, sum이 0인 경우에만 answer++를 실행해준다.
//조금 헷갈릴 수 있다. continue는 조건이 성립될 때, continue 해준다는 뜻이므로, 조건문 뒤의 코드를 건너뛰고(실행시키지않고) 루프를 계속한다는 뜻으로 이해하면 될 듯 하다. 참고로 break은 if문 안이 참일 경우에 루프문 자체를 탈출함.
//추가적으로, sum으로 변수설정을 해주니 가독성이 좋다.

function solution(number) {
  let result = 0;

  for (let i = 0, length = number.length; i < length; i++) {
    for (let j = i + 1; j < length; j++) {
      for (let k = j + 1; k < length; k++) {
        const sum = number[i] + number[j] + number[k];
        if (sum) continue;
        answer++;
      }
    }
  }

  return result;
}
